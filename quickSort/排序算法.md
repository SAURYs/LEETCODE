# 排序算法

## 快速排序

快速排序采取分治思想，下面是对一个典型数组的快速排序的三个步骤：

数组`A[p...r]`被划分为两个数组(可能为空)`A[p...q-1]`,`A[q+1....r]` ，其中`A[p...q-1]`中的每个数都小于`A[q]` ，对于`A[q+1....r]`中的每一个数都大于`A[q]` 。然后递归的对这些数组进行排序。

```C++
QuickSort(A,p,r){
    if(p<r){
        q = Partition(A,p,r);
        QuickSort(A,p,q-1);
        QuickSort(A,q+1,r);
    }
}
```

- Partition

  ```c
  //选取数组的最右边为pivot
  Partition(A,p,r){
      x = A[r];
      i = p-1;
      for j=p to r-1{
          if(A[j]<x){
              i = i+1;
              swap(A[j],A[i]);
          }
       
      }
      swap(A[i+1],A[r]);
      return i+1;
  }
  ```

### 快速排序的性能

快速排序的性能依赖于划分的是否平衡，如果划分的平衡，其性能相当于归并排序。如果划分的不平衡，其性能就和插入排序差不多了。

- 最坏情况划分

  当划分的子问题分别包含分别包含`n-1` 和`0`个元素时，因为划分的时间复杂度为$\Theta(n)$，对于大小为0的数组进行调用会立即返回。则算法的运行时间递推式为$T(n) = T(n-1) + \Theta(n)$，其时间复杂度为 $\Theta(n^2)$ 。在已经排序的数组会出现这种状况。
  
- 最好情况的划分

  两个子问题的规模都不大于$n/2$ ，在这种情况下$T(n)=2T(n/2)+\Theta(n)$ ,解为$T(n)=\Theta(nlgn)$ 。

- 平衡的划分

  任何一种常数比列的划分都会产生深度为$\Theta(lgn)$ 的递归树，其中每一层的代价都是$O(n)$ ，因此只要是划分市场书比例的，运行时间总是$O(nlgn)$ 。无论划分比例是$9:1$， 还是$99:1$ 。

### 快速排序的随机化版本(改进版)

与始终采取`A[r]`的版本不同，随机化的版本是随机从数组的元素中选取一个元素作为pivot,以此来达到期望的对数组的划分比较均衡。





